<script>
  // Firebase configuration and initialization
  let db = null;
  let firebaseInitialized = false;

  // Initialize Firebase
  function initializeFirebase() {
    try {
      // Check if Firebase is already initialized from fireatt.js
      if (typeof firebase !== 'undefined' && firebase.apps.length > 0) {
        // Try to get the cardApp instance
        let cardApp;
        try {
          cardApp = firebase.app('cardApp');
        } catch (e) {
          // If cardApp doesn't exist, use the default app
          cardApp = firebase.app();
        }
        
        db = cardApp.firestore();
        firebaseInitialized = true;
        console.log('Firebase initialized successfully');
        return true;
      } else {
        console.error('Firebase not loaded');
        return false;
      }
    } catch (error) {
      console.error('Firebase initialization error:', error);
      return false;
    }
  }

  // DOM elements
  const elements = {
    filterDate: document.getElementById('filterDate'),
    filterName: document.getElementById('filterName'),
    filterRC: document.getElementById('filterRC'),
    filterStatus: document.getElementById('filterStatus'),
    filterReason: document.getElementById('filterReason'),
    btnFilter: document.getElementById('btnFilter'),
    btnReset: document.getElementById('btnReset'),
    adjustmentBody: document.getElementById('adjustmentBody'),
    recordCount: document.getElementById('recordCount'),
    totalRequests: document.getElementById('totalRequests'),
    pendingRequests: document.getElementById('pendingRequests'),
    appliedRequests: document.getElementById('appliedRequests'),
    sentHrRequests: document.getElementById('sentHrRequests'),
    commentModal: document.getElementById('commentModal'),
    commentText: document.getElementById('commentText'),
    commentHistory: document.getElementById('commentHistory'),
    saveComment: document.getElementById('saveComment'),
    cancelComment: document.getElementById('cancelComment'),
    closeModal: document.querySelector('.close-modal'),
    notificationContainer: document.getElementById('notificationContainer'),
    firebaseStatus: document.getElementById('firebaseStatus')
  };

  // Application state
  let records = [];
  let filteredRecords = [];
  let currentCommentIndex = -1;
  let currentRecordId = null;
  let commentCheckInterval = null;
  let unsubscribeFirestore = null;

  // Initialize
  async function init() {
    setupEventListeners();
    
    // Initialize Firebase
    firebaseInitialized = initializeFirebase();
    
    if (firebaseInitialized && db) {
      // Update status indicator
      elements.firebaseStatus.className = 'firebase-status firebase-connected';
      elements.firebaseStatus.innerHTML = '<i class="fas fa-plug"></i> Connected to Firebase';
      
      await loadDataFromFirebase();
      setupRealtimeUpdates();
      showNotification('Firebase Connected', 'Successfully connected to database', 'success', 3000);
    } else {
      // Firebase not available
      elements.firebaseStatus.className = 'firebase-status firebase-disconnected';
      elements.firebaseStatus.innerHTML = '<i class="fas fa-plug"></i> Firebase Not Available';
      
      showNotification(
        'Firebase Error', 
        'Could not connect to Firebase. Please check your configuration.',
        'warning',
        5000
      );
      
      // Show empty state
      renderTable();
    }
    
    startCommentChecker();
  }

  // Load data from Firebase
  async function loadDataFromFirebase() {
    try {
      showNotification('Loading...', 'Fetching data from Firebase', 'info', 2000);
      
      console.log('Loading data from Firebase...');
      
      // Clear existing records
      records = [];
      
      // Get data from Firestore
      const snapshot = await db.collection('attendanceAdjustments').get();
      
      console.log(`Found ${snapshot.size} records in Firebase`);
      
      snapshot.forEach(doc => {
        const data = doc.data();
        console.log('Processing document:', doc.id, data);
        
        // Ensure all required fields exist with defaults
        records.push({
          id: doc.id,
          name: data.name || 'Unknown',
          rcno: data.rcno || 'N/A',
          date: data.date || new Date().toISOString().split('T')[0],
          reason: data.reason || 'Other',
          remarks: data.remarks || '',
          status: data.status || 'Pending',
          userComments: data.userComments || [],
          commentsRead: data.commentsRead !== undefined ? data.commentsRead : true,
          lastCommentCheck: data.lastCommentCheck || null,
          createdAt: data.createdAt || null,
          updatedAt: data.updatedAt || null
        });
      });
      
      console.log('Processed records:', records);
      
      // Sort records by date (newest first)
      records.sort((a, b) => new Date(b.date) - new Date(a.date));
      
      applyFilters();
      updateStats();
      
      if (records.length === 0) {
        showNotification('No Data', 'No attendance adjustment records found in database', 'info', 4000);
      } else {
        showNotification('Data Loaded', `Loaded ${records.length} records from Firebase`, 'success', 3000);
      }
      
    } catch (error) {
      console.error('Error loading data from Firebase:', error);
      showNotification(
        'Load Error', 
        'Failed to load data from Firebase: ' + error.message,
        'warning',
        5000
      );
      
      records = [];
      applyFilters();
      updateStats();
    }
  }

  // Setup real-time Firestore updates
  function setupRealtimeUpdates() {
    if (!firebaseInitialized || !db) {
      console.log('Firebase not available for real-time updates');
      return;
    }
    
    try {
      console.log('Setting up real-time Firestore listener...');
      
      unsubscribeFirestore = db.collection('attendanceAdjustments')
        .onSnapshot((snapshot) => {
          console.log('Real-time update received:', snapshot.docChanges().length, 'changes');
          
          let hasChanges = false;
          
          snapshot.docChanges().forEach((change) => {
            if (change.type === 'added' || change.type === 'modified') {
              const data = change.doc.data();
              const recordIndex = records.findIndex(r => r.id === change.doc.id);
              
              const recordData = {
                id: change.doc.id,
                name: data.name || 'Unknown',
                rcno: data.rcno || 'N/A',
                date: data.date || new Date().toISOString().split('T')[0],
                reason: data.reason || 'Other',
                remarks: data.remarks || '',
                status: data.status || 'Pending',
                userComments: data.userComments || [],
                commentsRead: data.commentsRead !== undefined ? data.commentsRead : true,
                lastCommentCheck: data.lastCommentCheck || null,
                createdAt: data.createdAt || null,
                updatedAt: data.updatedAt || null
              };
              
              if (recordIndex !== -1) {
                // Update existing record
                records[recordIndex] = recordData;
                console.log('Updated record:', change.doc.id);
              } else {
                // Add new record
                records.push(recordData);
                console.log('Added new record:', change.doc.id);
              }
              
              hasChanges = true;
            }
            
            if (change.type === 'removed') {
              records = records.filter(r => r.id !== change.doc.id);
              console.log('Removed record:', change.doc.id);
              hasChanges = true;
            }
          });
          
          if (hasChanges) {
            // Sort records by date (newest first)
            records.sort((a, b) => new Date(b.date) - new Date(a.date));
            applyFilters();
            updateStats();
            showNotification('Data Updated', 'Records have been updated', 'info', 2000);
          }
          
        }, (error) => {
          console.error('Firestore real-time error:', error);
          showNotification(
            'Sync Error',
            'Connection issue. Updates may be delayed.',
            'warning',
            4000
          );
        });
        
    } catch (error) {
      console.error('Error setting up real-time updates:', error);
    }
  }

  // Update record in Firebase
  async function updateRecordInFirebase(id, updates) {
    if (!firebaseInitialized || !db) {
      console.log('Firebase not available for update');
      return false;
    }
    
    try {
      // Add timestamp
      updates.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
      
      console.log('Updating record in Firebase:', id, updates);
      await db.collection('attendanceAdjustments').doc(id).update(updates);
      console.log('Record updated successfully');
      return true;
    } catch (error) {
      console.error('Error updating record in Firebase:', error);
      showNotification(
        'Update Error',
        'Failed to update record: ' + error.message,
        'warning',
        4000
      );
      return false;
    }
  }

  // Add new record to Firebase (for testing if needed)
  async function addSampleRecordToFirebase() {
    if (!firebaseInitialized || !db) return;
    
    try {
      const sampleRecord = {
        name: "Test User",
        rcno: "RC999",
        date: new Date().toISOString().split('T')[0],
        reason: "Sick Leave",
        remarks: "Test record added via system",
        status: "Pending",
        userComments: [],
        commentsRead: true,
        lastCommentCheck: null,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      
      await db.collection('attendanceAdjustments').add(sampleRecord);
      showNotification('Test Record Added', 'Added sample record to Firebase', 'success', 3000);
    } catch (error) {
      console.error('Error adding sample record:', error);
    }
  }

  // Setup event listeners
  function setupEventListeners() {
    elements.btnFilter.addEventListener('click', applyFilters);
    elements.btnReset.addEventListener('click', resetFilters);
    elements.saveComment.addEventListener('click', saveCommentHandler);
    elements.cancelComment.addEventListener('click', closeCommentModal);
    elements.closeModal.addEventListener('click', closeCommentModal);
    
    // Close modal when clicking outside
    elements.commentModal.addEventListener('click', (e) => {
      if (e.target === elements.commentModal) {
        closeCommentModal();
      }
    });
    
    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeCommentModal();
      }
    });
  }

  // Start checking for new comments
  function startCommentChecker() {
    commentCheckInterval = setInterval(() => {
      checkForNewComments();
    }, 3000);
  }

  // Check for new comments
  function checkForNewComments() {
    let hasNewComments = false;
    let newCommentRecords = [];
    
    records.forEach(record => {
      if (record.userComments && record.userComments.length > 0) {
        const lastComment = record.userComments[record.userComments.length - 1];
        const commentTime = new Date(lastComment.timestamp).getTime();
        const lastCheck = record.lastCommentCheck ? new Date(record.lastCommentCheck).getTime() : 0;
        
        if (commentTime > lastCheck && !record.commentsRead) {
          hasNewComments = true;
          newCommentRecords.push(record);
          record.lastCommentCheck = new Date().toISOString();
        }
      }
    });
    
    if (hasNewComments) {
      newCommentRecords.forEach(record => {
        showNotification(
          'New Comment Added',
          `${record.name} has a new comment`,
          'info',
          6000
        );
      });
      renderTable();
    }
  }

  // Notification system
  function showNotification(title, message, type = 'info', duration = 5000) {
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    
    const icon = type === 'success' ? 'fa-check-circle' : 
                 type === 'warning' ? 'fa-exclamation-triangle' : 
                 'fa-info-circle';
    
    notification.innerHTML = `
      <div class="notification-icon">
        <i class="fas ${icon}"></i>
      </div>
      <div class="notification-content">
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
      </div>
      <button class="notification-close">
        <i class="fas fa-times"></i>
      </button>
    `;
    
    elements.notificationContainer.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 10);
    
    notification.querySelector('.notification-close').addEventListener('click', () => {
      closeNotification(notification);
    });
    
    if (duration > 0) {
      setTimeout(() => closeNotification(notification), duration);
    }
    
    return notification;
  }
  
  function closeNotification(notification) {
    notification.classList.remove('show');
    notification.classList.add('hide');
    setTimeout(() => notification.remove(), 300);
  }

  // Filter functions
  function applyFilters() {
    const filters = {
      date: elements.filterDate.value,
      name: elements.filterName.value.toLowerCase(),
      rc: elements.filterRC.value.toLowerCase(),
      status: elements.filterStatus.value,
      reason: elements.filterReason.value
    };

    if (filters.status === 'Applied') {
      filteredRecords = records.filter(record => 
        record.status === 'Applied' &&
        matchesFilters(record, filters)
      );
    } else {
      filteredRecords = records.filter(record => 
        record.status !== 'Applied' &&
        matchesFilters(record, filters)
      );
    }

    renderTable();
  }

  function matchesFilters(record, filters) {
    return (
      (!filters.date || record.date === filters.date) &&
      (!filters.name || record.name.toLowerCase().includes(filters.name)) &&
      (!filters.rc || record.rcno.toLowerCase().includes(filters.rc)) &&
      (!filters.status || record.status === filters.status) &&
      (!filters.reason || record.reason === filters.reason)
    );
  }

  function resetFilters() {
    elements.filterDate.value = '';
    elements.filterName.value = '';
    elements.filterRC.value = '';
    elements.filterStatus.value = '';
    elements.filterReason.value = '';
    applyFilters();
    showNotification('Filters Reset', 'Showing all pending records', 'info', 3000);
  }

  // Render functions
  function renderTable() {
    elements.adjustmentBody.innerHTML = '';
    elements.recordCount.textContent = `(${filteredRecords.length} records)`;

    if (filteredRecords.length === 0) {
      elements.adjustmentBody.innerHTML = `
        <tr>
          <td colspan="7" class="empty-state">
            <i class="fas fa-inbox"></i>
            <p>No adjustment records found</p>
            ${records.length === 0 ? '<p style="font-size: 0.7rem; margin-top: 5px;">No data available in Firebase</p>' : ''}
          </td>
        </tr>
      `;
      return;
    }

    filteredRecords.forEach((record, index) => {
      const row = document.createElement('tr');
      row.innerHTML = createTableRow(record, index);
      elements.adjustmentBody.appendChild(row);
    });

    attachRowEventListeners();
  }

  function createTableRow(record, index) {
    const actionButtons = getActionButtons(record, index);
    const commentButton = getCommentButton(record, index);
    
    return `
      <td>${record.name}</td>
      <td>${record.rcno}</td>
      <td>${record.date}</td>
      <td><span class="reason-badge ${getReasonClass(record.reason)}">${record.reason}</span></td>
      <td>${record.remarks}</td>
      <td><span class="status-badge ${getStatusClass(record.status)}">${record.status}</span></td>
      <td>
        <div style="display: flex; gap: 4px; flex-wrap: wrap;">
          ${actionButtons}
          ${commentButton}
        </div>
      </td>
    `;
  }

  function getActionButtons(record, index) {
    switch(record.status) {
      case 'Pending':
        return `
          <button class="action-btn action-apply" data-index="${index}">
            <i class="fas fa-check"></i> Apply
          </button>
          <button class="action-btn action-send-hr" data-index="${index}">
            <i class="fas fa-paper-plane"></i> HR
          </button>
        `;
      case 'Applied':
        return `
          <button class="action-btn action-apply" data-index="${index}" style="opacity: 0.6; cursor: not-allowed;">
            <i class="fas fa-check"></i> Applied
          </button>
        `;
      case 'Sent to HR':
        return `
          <button class="action-btn action-apply" data-index="${index}">
            <i class="fas fa-check"></i> Apply
          </button>
          <button class="action-btn action-sent-hr" data-index="${index}">
            <i class="fas fa-paper-plane"></i> Sent
          </button>
        `;
      case 'Action Required':
        return `
          <button class="action-btn action-apply" data-index="${index}">
            <i class="fas fa-check"></i> Apply
          </button>
          <button class="action-btn action-send-hr" data-index="${index}">
            <i class="fas fa-paper-plane"></i> HR
          </button>
        `;
      default:
        return '';
    }
  }

  function getCommentButton(record, index) {
    const hasUnread = record.userComments && record.userComments.length > 0 && !record.commentsRead;
    const commentClass = hasUnread ? 'action-comment has-comments' : 'action-comment';
    const commentText = hasUnread ? 
      `<i class="fas fa-comment"></i> Comment (${record.userComments.length})` :
      `<i class="fas fa-comment"></i> Comment`;
    
    return `<button class="action-btn ${commentClass}" data-index="${index}">${commentText}</button>`;
  }

  function attachRowEventListeners() {
    document.querySelectorAll('.action-apply:not([style*="opacity"])').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.currentTarget.getAttribute('data-index'));
        markAsApplied(index);
      });
    });

    document.querySelectorAll('.action-send-hr').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.currentTarget.getAttribute('data-index'));
        sendToHR(index);
      });
    });

    document.querySelectorAll('.action-comment').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.currentTarget.getAttribute('data-index'));
        openCommentModal(index);
      });
    });
  }

  // Comment modal functions
  function openCommentModal(index) {
    currentCommentIndex = index;
    const record = filteredRecords[index];
    
    // Mark as read when opened
    record.commentsRead = true;
    updateRecordInMainArray(record.id, { commentsRead: true });
    if (firebaseInitialized) {
      updateRecordInFirebase(record.id, { commentsRead: true });
    }
    
    elements.commentText.value = '';
    displayCommentHistory(record);
    elements.commentModal.style.display = 'flex';
    renderTable();
  }

  function displayCommentHistory(record) {
    elements.commentHistory.innerHTML = '<h4>Comment History</h4>';
    
    if (!record.userComments || record.userComments.length === 0) {
      elements.commentHistory.innerHTML += '<p>No comments yet.</p>';
      return;
    }
    
    record.userComments.forEach(comment => {
      const commentItem = document.createElement('div');
      commentItem.className = 'comment-item';
      commentItem.innerHTML = `
        <div><strong>${comment.user || 'User'}:</strong> ${comment.text}</div>
        <div class="comment-date">${new Date(comment.timestamp).toLocaleString()}</div>
      `;
      elements.commentHistory.appendChild(commentItem);
    });
  }

  function closeCommentModal() {
    elements.commentModal.style.display = 'none';
    currentCommentIndex = -1;
  }

  function saveCommentHandler() {
    if (currentCommentIndex === -1) return;
    
    const comment = elements.commentText.value.trim();
    if (!comment) {
      showNotification('Comment Required', 'Please enter a comment', 'warning', 3000);
      return;
    }
    
    saveComment(comment);
  }

  function saveComment(commentText) {
    const record = filteredRecords[currentCommentIndex];
    const timestamp = new Date().toISOString();
    
    if (!record.userComments) record.userComments = [];
    
    record.userComments.push({
      text: commentText,
      timestamp: timestamp,
      user: "Current User"
    });
    
    record.commentsRead = false;
    record.lastCommentCheck = timestamp;
    
    updateRecordInMainArray(record.id, {
      userComments: record.userComments,
      commentsRead: false,
      lastCommentCheck: timestamp
    });
    
    // Update in Firebase if connected
    if (firebaseInitialized) {
      updateRecordInFirebase(record.id, {
        userComments: record.userComments,
        commentsRead: false,
        lastCommentCheck: timestamp
      });
    }
    
    // Check for status change
    if (commentText.toLowerCase().includes('mc needed') || 
        commentText.toLowerCase().includes('document') ||
        commentText.toLowerCase().includes('action required')) {
      record.status = 'Action Required';
      updateRecordInMainArray(record.id, { status: 'Action Required' });
      if (firebaseInitialized) {
        updateRecordInFirebase(record.id, { status: 'Action Required' });
      }
      showNotification(
        'Comment Added & Status Updated',
        `Comment added to ${record.name}. Status changed to Action Required.`,
        'success',
        5000
      );
    } else {
      showNotification(
        'Comment Added',
        `Comment added to ${record.name}'s record`,
        'success',
        4000
      );
    }
    
    updateStats();
    renderTable();
    closeCommentModal();
  }

  // Record actions
  function markAsApplied(index) {
    if (!confirm('Mark this request as applied?')) return;
    
    const record = filteredRecords[index];
    record.status = 'Applied';
    updateRecordInMainArray(record.id, { status: 'Applied' });
    if (firebaseInitialized) {
      updateRecordInFirebase(record.id, { status: 'Applied' });
    }
    
    showNotification('Request Applied', `${record.name} marked as applied`, 'success', 4000);
    updateStats();
    applyFilters();
  }

  function sendToHR(index) {
    if (!confirm('Send this request to HR?')) return;
    
    const record = filteredRecords[index];
    record.status = 'Sent to HR';
    updateRecordInMainArray(record.id, { status: 'Sent to HR' });
    if (firebaseInitialized) {
      updateRecordInFirebase(record.id, { status: 'Sent to HR' });
    }
    
    showNotification('Sent to HR', `${record.name} sent to HR department`, 'info', 4000);
    updateStats();
    renderTable();
  }

  // Utility functions
  function getReasonClass(reason) {
    const classMap = {
      'Sick Leave': 'reason-sick-leave',
      'No Out Card': 'reason-no-out-card',
      'No In Card': 'reason-no-out-card', // Use same style as No Out Card
      'Duty Change': 'reason-duty-change',
      'Personal Leave': 'reason-personal',
      'Training': 'reason-training',
      'Fine Remove': 'reason-other'
    };
    return classMap[reason] || 'reason-other';
  }

  function getStatusClass(status) {
    const classMap = {
      'Pending': 'status-pending',
      'Applied': 'status-applied',
      'Sent to HR': 'status-sent-hr',
      'Action Required': 'status-action-required'
    };
    return classMap[status] || 'status-pending';
  }

  function updateRecordInMainArray(id, updates) {
    const index = records.findIndex(r => r.id === id);
    if (index !== -1) {
      records[index] = { ...records[index], ...updates };
    }
  }

  function updateStats() {
    elements.totalRequests.textContent = records.length;
    elements.pendingRequests.textContent = records.filter(r => r.status === 'Pending').length;
    elements.sentHrRequests.textContent = records.filter(r => r.status === 'Sent to HR').length;
    elements.appliedRequests.textContent = records.filter(r => r.status === 'Applied').length;
  }

  // Cleanup function
  function cleanup() {
    if (commentCheckInterval) {
      clearInterval(commentCheckInterval);
    }
    if (unsubscribeFirestore) {
      unsubscribeFirestore();
    }
  }

  // Start the application
  init();

  // Make addSampleRecordToFirebase available globally for testing
  window.addSampleRecordToFirebase = addSampleRecordToFirebase;
</script>
